/**
 * This file was auto-generated by the Titanium Module SDK helper for Android
 * Appcelerator Titanium Mobile
 * Copyright (c) 2009-2010 by Appcelerator, Inc. All Rights Reserved.
 * Licensed under the terms of the Apache Public License
 * Please see the LICENSE included with this distribution for details.
 *
 */
package de.appwerft.audiomanager;

import java.util.ArrayList;

import org.appcelerator.kroll.KrollDict;
import org.appcelerator.kroll.KrollFunction;
import org.appcelerator.kroll.KrollModule;
import org.appcelerator.kroll.annotations.Kroll;
import org.appcelerator.titanium.TiApplication;

import android.app.Activity;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.media.AudioDeviceInfo;
import android.media.AudioFormat;
import android.media.AudioManager;
import android.view.KeyEvent;

@Kroll.module(name = "Audiofocus", id = "de.appwerft.audiomanager")
public class AudiomanagerModule extends KrollModule {

	private KrollFunction onChangedCallback = null;

	public static AudioManager.OnAudioFocusChangeListener afChangeListener;

	@Kroll.constant
	public static final int STREAM_MUSIC = AudioManager.STREAM_MUSIC;
	@Kroll.constant
	public static final int STREAM_ALARM = AudioManager.STREAM_ALARM;
	@Kroll.constant
	public static final int STREAM_DTMF = AudioManager.STREAM_DTMF;
	@Kroll.constant
	public static final int AUDIOFOCUS_GAIN = AudioManager.AUDIOFOCUS_GAIN;
	@Kroll.constant
	public static final int AUDIOFOCUS_GAIN_TRANSIENT = AudioManager.AUDIOFOCUS_GAIN_TRANSIENT;
	@Kroll.constant
	public static final int AUDIOFOCUS_GAIN_TRANSIENT_EXCLUSIVE = AudioManager.AUDIOFOCUS_GAIN_TRANSIENT_EXCLUSIVE;
	@Kroll.constant
	public static final int AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK = AudioManager.AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK;
	@Kroll.constant
	public static final int AUDIOFOCUS_REQUEST_GRANTED = AudioManager.AUDIOFOCUS_REQUEST_GRANTED;
	@Kroll.constant
	public static final int AUDIOROUTE_HEADSET = 0;
	@Kroll.constant
	public static final int AUDIOROUTE_HDMI = 1;
	@Kroll.constant
	public static final int AUDIOROUTE_LOUDSPEAKER = 2;

	@Kroll.constant
	public static final int KEYCODE_MEDIA_STOP = KeyEvent.KEYCODE_MEDIA_STOP;
	@Kroll.constant
	public static final int KEYCODE_MEDIA_PLAY_PAUSE = KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE;
	@Kroll.constant
	public static final int KEYCODE_HEADSETHOOK = KeyEvent.KEYCODE_HEADSETHOOK;
	@Kroll.constant
	public static final int KEYCODE_MEDIA_NEXT = KeyEvent.KEYCODE_MEDIA_NEXT;
	@Kroll.constant
	public static final int KEYCODE_MEDIA_PREVIOUS = KeyEvent.KEYCODE_MEDIA_PREVIOUS;
	@Kroll.constant
	public static final int KEYCODE_MEDIA_PAUSE = KeyEvent.KEYCODE_MEDIA_PAUSE;
	@Kroll.constant
	public static final int KEYCODE_MEDIA_PLAY = KeyEvent.KEYCODE_MEDIA_PLAY;

	private AudioManager am;
	private BroadcastReceiver receiver;
	private RemoteControlReceiver keylistener;
	private KrollFunction onActionCallback;
	private KrollFunction onKeyCallback;
	private IntentFilter intentFilter;
	private Context context;

	public AudiomanagerModule() {
		super();
		context = TiApplication.getInstance().getApplicationContext();
		am = (AudioManager) context.getSystemService(Context.AUDIO_SERVICE);
		receiver = new NoisyAudioStreamReceiver();
		keylistener = new RemoteControlReceiver();
		intentFilter = new IntentFilter(
				AudioManager.ACTION_AUDIO_BECOMING_NOISY);
	}

	@Kroll.onAppCreate
	public void onAppCreate(TiApplication app) {
	}

	public void onDestroy(Activity activity) {
		context.unregisterReceiver(receiver);
		context.unregisterReceiver(keylistener);
		super.onDestroy(activity);
	}

	@SuppressWarnings("deprecation")
	@Kroll.method
	public String getAudioRoute() {
		if (am.isBluetoothA2dpOn()) {
			return "bluetooth";
		} else if (am.isSpeakerphoneOn()) {
			return "speaker";
			// Adjust output for Speakerphone.
		} else if (am.isWiredHeadsetOn()) {
			return "headset";
			// Adjust output for headsets
		} else {
			// If audio plays and noone can hear it, is it still playing?
			return null;

		}

	}

	@Kroll.method
	public void registerRouteListener(KrollDict opts) {
		if (opts.containsKeyAndNotNull("onAction")) {
			// binding the local KrollFunc to javascript function
			onActionCallback = (KrollFunction) opts.get("onAction");
		}
		context.registerReceiver(receiver, intentFilter);

	}

	@Kroll.method
	public void unregisterRouteListener(KrollDict opts) {
		context.unregisterReceiver(receiver);
	}

	@Kroll.method
	public void registerMediaButtonEventReceiver(KrollDict opts) {
		if (opts.containsKeyAndNotNull("keypressed")) {
			onKeyCallback = (KrollFunction) opts.get("keypressed");
		}
		context.registerReceiver(keylistener, intentFilter);

	}

	@Kroll.method
	public void unregisterMediaButtonEventReceiver() {
		context.unregisterReceiver(keylistener);
	}

	@Kroll.method
	public int requestAudioFocus(KrollDict opts) {
		afChangeListener = new AudioManager.OnAudioFocusChangeListener() {
			public void onAudioFocusChange(int focusChange) {
				KrollDict dict = new KrollDict();
				switch (focusChange) {
				case AudioManager.AUDIOFOCUS_LOSS_TRANSIENT:
					dict.put("state", "paused");
					break;
				case AudioManager.AUDIOFOCUS_GAIN:
					dict.put("state", "resumed");
					break;
				case AudioManager.AUDIOFOCUS_LOSS:
					dict.put("state", "stopped");
					break;
				case AudioManager.AUDIOFOCUS_LOSS_TRANSIENT_CAN_DUCK:
					dict.put("state", "duck");
					break;
				}
				if (onChangedCallback != null)
					onChangedCallback.call(getKrollObject(), dict);
			}
		};
		int streamType = AudioManager.STREAM_MUSIC;
		int focusType = AudioManager.AUDIOFOCUS_GAIN;
		if (opts != null) {
			if (opts.containsKeyAndNotNull("streamType"))
				streamType = opts.getInt("streamType");
			if (opts.containsKeyAndNotNull("focusType"))
				focusType = opts.getInt("onchanged");
			if (opts.containsKeyAndNotNull("onChanged"))
				onChangedCallback = (KrollFunction) opts.get("onChanged");
		}
		Context context = TiApplication.getInstance().getApplicationContext();
		AudioManager am = (AudioManager) context
				.getSystemService(Context.AUDIO_SERVICE);
		int result = am.requestAudioFocus(afChangeListener, streamType,
				focusType);
		return result;
	}

	@SuppressWarnings("deprecation")
	@Kroll.method
	public KrollDict getDevices() {
		AudioDeviceInfo[] devices = am.getDevices(AudioManager.GET_DEVICES_ALL);
		KrollDict dict = new KrollDict();
		ArrayList<KrollDict> listOfDevices = new ArrayList<KrollDict>();
		for (AudioDeviceInfo device : devices) {

			KrollDict deviceDict = new KrollDict();
			deviceDict.put("productName", device.getProductName());
			deviceDict.put("isSource", device.isSource());
			deviceDict.put("isSink", device.isSink());
			int[] sampleRates = device.getSampleRates();
			deviceDict.put("sampleRates", sampleRates);
			int[] channelMasks = device.getChannelMasks();
			ArrayList<String> listofMasks = new ArrayList<String>();
			for (int i = 0; i < channelMasks.length; i++) {
				switch (channelMasks[i]) {
				case AudioFormat.CHANNEL_CONFIGURATION_MONO:
					listofMasks.add("mono");
					break;
				case AudioFormat.CHANNEL_CONFIGURATION_STEREO:
					listofMasks.add("stereo");
					break;
				case AudioFormat.CHANNEL_IN_STEREO:
					listofMasks.add("stereo");
					break;
				case AudioFormat.CHANNEL_OUT_7POINT1_SURROUND:
					listofMasks.add("7.1_surround");
					break;
				case AudioFormat.CHANNEL_OUT_5POINT1:
					listofMasks.add("5.1");
					break;
				case AudioFormat.CHANNEL_IN_BACK:
					listofMasks.add("back");
					break;
				case AudioFormat.CHANNEL_IN_FRONT:
					listofMasks.add("front");
					break;
				case AudioFormat.CHANNEL_IN_BACK_PROCESSED:
					listofMasks.add("back:processed");
					break;
				default:
					listofMasks.add("unknown");
				}
			}
			deviceDict.put("channelMasks", listofMasks);
			String type = "";
			switch (device.getType()) {
			case AudioDeviceInfo.TYPE_AUX_LINE:
				type = "aux_line";
				break;
			case AudioDeviceInfo.TYPE_BLUETOOTH_A2DP:
				type = "bluetooth_a2dp";
				break;
			case AudioDeviceInfo.TYPE_BLUETOOTH_SCO:
				type = "bluetooth_sco";
				break;
			case AudioDeviceInfo.TYPE_BUILTIN_SPEAKER:
				type = "builtin_speaker";
				break;
			case AudioDeviceInfo.TYPE_BUILTIN_EARPIECE:
				type = "builtin_earpiece";
				break;
			case AudioDeviceInfo.TYPE_BUILTIN_MIC:
				type = "builtin_mic";
				break;
			case AudioDeviceInfo.TYPE_DOCK:
				type = "dock";
				break;
			case AudioDeviceInfo.TYPE_FM:
				type = "fm";
				break;
			case AudioDeviceInfo.TYPE_HDMI:
				type = "hdmi";
				break;
			case AudioDeviceInfo.TYPE_HDMI_ARC:
				type = "hdmi_arc";
				break;
			case AudioDeviceInfo.TYPE_IP:
				type = "ip";
				break;
			case AudioDeviceInfo.TYPE_LINE_ANALOG:
				type = "line_analog";
				break;
			case AudioDeviceInfo.TYPE_LINE_DIGITAL:
				type = "line_digital";
				break;
			case AudioDeviceInfo.TYPE_TELEPHONY:
				type = "teleohony";
				break;
			case AudioDeviceInfo.TYPE_TV_TUNER:
				type = "tv_tuner";
				break;
			case AudioDeviceInfo.TYPE_USB_ACCESSORY:
				type = "usb_accessory";
				break;
			case AudioDeviceInfo.TYPE_USB_DEVICE:
				type = "usb_device";
				break;
			case AudioDeviceInfo.TYPE_WIRED_HEADPHONES:
				type = "rired_headphones";
				break;
			case AudioDeviceInfo.TYPE_WIRED_HEADSET:
				type = "rired_headset";
				break;
			}
			deviceDict.put("type", type);
			listOfDevices.add(deviceDict);
		}
		dict.put("devices", listOfDevices);
		return dict;
	}

	@Kroll.method
	public void abandonAudioFocus() {
		Context context = TiApplication.getInstance().getApplicationContext();
		AudioManager am = (AudioManager) context
				.getSystemService(Context.AUDIO_SERVICE);
		am.abandonAudioFocus(afChangeListener);
	}

	private class NoisyAudioStreamReceiver extends BroadcastReceiver {
		@Override
		public void onReceive(Context context, Intent intent) {
			KrollDict dict = new KrollDict();
			if (AudioManager.ACTION_AUDIO_BECOMING_NOISY.equals(intent
					.getAction())) {
				dict.put("device", AUDIOROUTE_LOUDSPEAKER);
			}
			if (AudioManager.ACTION_HDMI_AUDIO_PLUG.equals(intent.getAction())) {
				dict.put("device", AUDIOROUTE_HDMI);
			}
			if (AudioManager.ACTION_HEADSET_PLUG.equals(intent.getAction())) {
				dict.put("device", AUDIOROUTE_HEADSET);
			}
			onActionCallback.call(getKrollObject(), dict);
		}
	}

	private class RemoteControlReceiver extends BroadcastReceiver {
		@Override
		public void onReceive(Context context, Intent intent) {
			if (Intent.ACTION_MEDIA_BUTTON.equals(intent.getAction())) {
				KeyEvent event = (KeyEvent) intent
						.getParcelableExtra(Intent.EXTRA_KEY_EVENT);
				KrollDict dict = new KrollDict();
				dict.put("keycode", event.getKeyCode());
				onKeyCallback.call(getKrollObject(), dict);
			}
		}
	}
}