/**
 * This file was auto-generated by the Titanium Module SDK helper for Android
 * Appcelerator Titanium Mobile
 * Copyright (c) 2009-2010 by Appcelerator, Inc. All Rights Reserved.
 * Licensed under the terms of the Apache Public License
 * Please see the LICENSE included with this distribution for details.
 *
 */
package de.appwerft.audiomanager;

import org.appcelerator.kroll.KrollDict;
import org.appcelerator.kroll.KrollFunction;
import org.appcelerator.kroll.KrollModule;
import org.appcelerator.kroll.annotations.Kroll;
import org.appcelerator.titanium.TiApplication;

import android.app.Activity;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.media.AudioManager;
import android.view.KeyEvent;

@Kroll.module(name = "Audiofocus", id = "de.appwerft.audiomanager")
public class AudiomanagerModule extends KrollModule {

	private KrollFunction onChangedCallback = null;

	public static AudioManager.OnAudioFocusChangeListener afChangeListener;

	@Kroll.constant
	public static final int STREAM_MUSIC = AudioManager.STREAM_MUSIC;
	@Kroll.constant
	public static final int STREAM_ALARM = AudioManager.STREAM_ALARM;
	@Kroll.constant
	public static final int STREAM_DTMF = AudioManager.STREAM_DTMF;
	@Kroll.constant
	public static final int AUDIOFOCUS_GAIN = AudioManager.AUDIOFOCUS_GAIN;
	@Kroll.constant
	public static final int AUDIOFOCUS_GAIN_TRANSIENT = AudioManager.AUDIOFOCUS_GAIN_TRANSIENT;
	@Kroll.constant
	public static final int AUDIOFOCUS_GAIN_TRANSIENT_EXCLUSIVE = AudioManager.AUDIOFOCUS_GAIN_TRANSIENT_EXCLUSIVE;
	@Kroll.constant
	public static final int AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK = AudioManager.AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK;
	@Kroll.constant
	public static final int AUDIOFOCUS_REQUEST_GRANTED = AudioManager.AUDIOFOCUS_REQUEST_GRANTED;
	@Kroll.constant
	public static final int AUDIOROUTE_HEADSET = 0;
	@Kroll.constant
	public static final int AUDIOROUTE_HDMI = 1;
	@Kroll.constant
	public static final int AUDIOROUTE_LOUDSPEAKER = 2;

	@Kroll.constant
	public static final int KEYCODE_MEDIA_STOP = KeyEvent.KEYCODE_MEDIA_STOP;
	@Kroll.constant
	public static final int KEYCODE_MEDIA_PLAY_PAUSE = KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE;
	@Kroll.constant
	public static final int KEYCODE_HEADSETHOOK = KeyEvent.KEYCODE_HEADSETHOOK;
	@Kroll.constant
	public static final int KEYCODE_MEDIA_NEXT = KeyEvent.KEYCODE_MEDIA_NEXT;
	@Kroll.constant
	public static final int KEYCODE_MEDIA_PREVIOUS = KeyEvent.KEYCODE_MEDIA_PREVIOUS;
	@Kroll.constant
	public static final int KEYCODE_MEDIA_PAUSE = KeyEvent.KEYCODE_MEDIA_PAUSE;
	@Kroll.constant
	public static final int KEYCODE_MEDIA_PLAY = KeyEvent.KEYCODE_MEDIA_PLAY;

	private AudioManager am;
	private BroadcastReceiver receiver;
	private RemoteControlReceiver keylistener;
	private KrollFunction onActionCallback;
	private KrollFunction onKeyCallback;
	private IntentFilter intentFilter;
	private Context context;

	public AudiomanagerModule() {
		super();
		context = TiApplication.getInstance().getApplicationContext();
		am = (AudioManager) context.getSystemService(Context.AUDIO_SERVICE);
		receiver = new NoisyAudioStreamReceiver();
		keylistener = new RemoteControlReceiver();
		intentFilter = new IntentFilter(
				AudioManager.ACTION_AUDIO_BECOMING_NOISY);
	}

	@Kroll.onAppCreate
	public void onAppCreate(TiApplication app) {

	}

	public void onDestroy(Activity activity) {
		context.unregisterReceiver(receiver);
		context.unregisterReceiver(keylistener);
		super.onDestroy(activity);
	}

	@SuppressWarnings("deprecation")
	@Kroll.method
	public String getAudioRoute() {
		if (am.isBluetoothA2dpOn()) {
			return "bluetooth";
		} else if (am.isSpeakerphoneOn()) {
			return "speaker";
			// Adjust output for Speakerphone.
		} else if (am.isWiredHeadsetOn()) {
			return "headset";
			// Adjust output for headsets
		} else {
			// If audio plays and noone can hear it, is it still playing?
			return null;

		}

	}

	@Kroll.method
	public void registerRouteListener(KrollDict opts) {
		if (opts.containsKeyAndNotNull("onAction")) {
			// binding the local KrollFunc to javascript function
			onActionCallback = (KrollFunction) opts.get("onAction");
		}
		context.registerReceiver(receiver, intentFilter);

	}

	@Kroll.method
	public void unregisterRouteListener(KrollDict opts) {
		context.unregisterReceiver(receiver);
	}

	@Kroll.method
	public void registerMediaButtonEventReceiver(KrollDict opts) {
		if (opts.containsKeyAndNotNull("keypressed")) {
			onKeyCallback = (KrollFunction) opts.get("keypressed");
		}
		context.registerReceiver(keylistener, intentFilter);

	}

	@Kroll.method
	public void unregisterMediaButtonEventReceiver() {
		context.unregisterReceiver(keylistener);
	}

	@Kroll.method
	public int requestAudioFocus(KrollDict opts) {
		afChangeListener = new AudioManager.OnAudioFocusChangeListener() {
			public void onAudioFocusChange(int focusChange) {
				KrollDict dict = new KrollDict();
				switch (focusChange) {
				case AudioManager.AUDIOFOCUS_LOSS_TRANSIENT:
					dict.put("state", "paused");
					break;
				case AudioManager.AUDIOFOCUS_GAIN:
					dict.put("state", "resumed");
					break;
				case AudioManager.AUDIOFOCUS_LOSS:
					dict.put("state", "stopped");
					break;
				case AudioManager.AUDIOFOCUS_LOSS_TRANSIENT_CAN_DUCK:
					dict.put("state", "duck");
					break;
				}
				if (onChangedCallback != null)
					onChangedCallback.call(getKrollObject(), dict);
			}
		};
		int streamType = AudioManager.STREAM_MUSIC;
		int focusType = AudioManager.AUDIOFOCUS_GAIN;
		if (opts != null) {
			if (opts.containsKeyAndNotNull("streamType"))
				streamType = opts.getInt("streamType");
			if (opts.containsKeyAndNotNull("focusType"))
				focusType = opts.getInt("onchanged");
			if (opts.containsKeyAndNotNull("onChanged"))
				onChangedCallback = (KrollFunction) opts.get("onChanged");
		}
		Context context = TiApplication.getInstance().getApplicationContext();
		AudioManager am = (AudioManager) context
				.getSystemService(Context.AUDIO_SERVICE);
		int result = am.requestAudioFocus(afChangeListener, streamType,
				focusType);
		return result;
	}

	@Kroll.method
	public void abandonAudioFocus() {
		Context context = TiApplication.getInstance().getApplicationContext();
		AudioManager am = (AudioManager) context
				.getSystemService(Context.AUDIO_SERVICE);
		am.abandonAudioFocus(afChangeListener);
	}

	private class NoisyAudioStreamReceiver extends BroadcastReceiver {
		@Override
		public void onReceive(Context context, Intent intent) {
			KrollDict dict = new KrollDict();
			if (AudioManager.ACTION_AUDIO_BECOMING_NOISY.equals(intent
					.getAction())) {
				dict.put("device", AUDIOROUTE_LOUDSPEAKER);
			}
			if (AudioManager.ACTION_HDMI_AUDIO_PLUG.equals(intent.getAction())) {
				dict.put("device", AUDIOROUTE_HDMI);
			}
			if (AudioManager.ACTION_HEADSET_PLUG.equals(intent.getAction())) {
				dict.put("device", AUDIOROUTE_HEADSET);
			}
			onActionCallback.call(getKrollObject(), dict);
		}
	}

	private class RemoteControlReceiver extends BroadcastReceiver {
		@Override
		public void onReceive(Context context, Intent intent) {
			if (Intent.ACTION_MEDIA_BUTTON.equals(intent.getAction())) {
				KeyEvent event = (KeyEvent) intent
						.getParcelableExtra(Intent.EXTRA_KEY_EVENT);
				KrollDict dict = new KrollDict();
				dict.put("keycode", event.getKeyCode());
				onKeyCallback.call(getKrollObject(), dict);
			}
		}
	}
}